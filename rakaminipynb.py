# -*- coding: utf-8 -*-
"""rakaminipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12gCyjisSX-PCf1VXJw3bSldQaIrG0D0N

# Problem Research

Memprediksi apakah seorang klien akan mengalami keterlambatan pembayaran pada pinjaman mereka atau tidak. Secara lebih spesifik, tujuan dari analisis ini adalah:



1.   **Peningkatan Efisiensi**,
Memungkinkan lembaga keuangan untuk mengalokasikan sumber daya dengan lebih efisien dengan fokus pada aplikasi pinjaman yang berpotensi menghasilkan keuntungan atau memiliki risiko yang dapat dikelola.
2.   **Prediksi Risiko Kredit**,
Memprediksi kemungkinan terjadinya keterlambatan pembayaran (late payment) pada pinjaman tersebut. Menentukan risiko kredit dari setiap aplikasi pinjaman yang diajukan.
3.  **Pengambilan Keputusan Peminjaman**, Membantu dalam menentukan syarat dan ketentuan pinjaman, termasuk jumlah kredit, tingkat bunga, dan jangka waktu pembayaran.

# Library
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import LabelEncoder

from sklearn import datasets, linear_model, metrics
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import cross_val_score

"""# Load Data"""

from google.colab import drive
drive.mount('/content/drive')

"""## Application Data"""

train = '/content/drive/My Drive/HCI/application_train.csv'

train = pd.read_csv(train)

train.head(15)

test = '/content/drive/My Drive/HCI/application_test.csv'

test = pd.read_csv(test)

test

test.shape

train.shape

"""# Pre-Processing

## Application Data
"""

for column in train.columns:
    print(column, train[column].isnull().sum())

train_new = train.drop(columns=['AMT_REQ_CREDIT_BUREAU_YEAR', 'AMT_REQ_CREDIT_BUREAU_QRT', 'AMT_REQ_CREDIT_BUREAU_MON', 'AMT_REQ_CREDIT_BUREAU_WEEK',
                                'AMT_REQ_CREDIT_BUREAU_DAY', 'AMT_REQ_CREDIT_BUREAU_HOUR', 'OWN_CAR_AGE', 'EXT_SOURCE_1', 'EXT_SOURCE_2',
                                'EXT_SOURCE_3', 'APARTMENTS_AVG', 'BASEMENTAREA_AVG', 'YEARS_BEGINEXPLUATATION_AVG', 'YEARS_BUILD_AVG',
                                'FONDKAPREMONT_MODE', 'LIVINGAPARTMENTS_MEDI', 'NONLIVINGAPARTMENTS_AVG', 'LIVINGAPARTMENTS_AVG',
                                'LIVINGAREA_AVG', 'NONLIVINGAREA_AVG'])

test_new = test.drop(columns=['AMT_REQ_CREDIT_BUREAU_YEAR', 'AMT_REQ_CREDIT_BUREAU_QRT', 'AMT_REQ_CREDIT_BUREAU_MON', 'AMT_REQ_CREDIT_BUREAU_WEEK',
                                'AMT_REQ_CREDIT_BUREAU_DAY', 'AMT_REQ_CREDIT_BUREAU_HOUR', 'OWN_CAR_AGE', 'EXT_SOURCE_1', 'EXT_SOURCE_2',
                                'EXT_SOURCE_3', 'APARTMENTS_AVG', 'BASEMENTAREA_AVG', 'YEARS_BEGINEXPLUATATION_AVG', 'YEARS_BUILD_AVG',
                                'FONDKAPREMONT_MODE', 'LIVINGAPARTMENTS_MEDI', 'NONLIVINGAPARTMENTS_AVG', 'LIVINGAPARTMENTS_AVG',
                                'LIVINGAREA_AVG', 'NONLIVINGAREA_AVG'])

train_new.duplicated().sum()

train_new.shape

test_new.shape

train_drop = train_new.dropna()

test_drop = test_new.dropna()

train_drop.shape

test_drop.shape

for column in train.columns:
    print(train_drop.dtypes)

train_drop.head()

"""# VISUALISASI

## Application
"""

plt.pie(train_drop.groupby(by=["TARGET"]).size(), labels = train_drop["TARGET"].unique(),autopct = "%0.2f", colors=['blue', 'yellow'])
plt.title('target')
plt.show()

sns.countplot(x=train_drop['TARGET'], order=train_drop['TARGET'].value_counts().index)
plt.title('target');

sns.countplot(x=train_drop['CODE_GENDER'], order=train_drop['CODE_GENDER'].value_counts().index, color='skyblue')
plt.title('gender');

plt.pie(train_drop.groupby(by=["NAME_CONTRACT_TYPE"]).size(), labels = train_drop["NAME_CONTRACT_TYPE"].unique(),autopct = "%0.2f")
plt.title('contract type')
plt.show()

data = train_drop['AMT_INCOME_TOTAL']

plt.figure(figsize=(10, 6))
plt.hist(data, bins=5, color='skyblue', edgecolor='black')
plt.title('Distribusi AMT_INCOME_TOTAL')
plt.xlabel('AMT_INCOME_TOTAL')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()

data = train_drop['AMT_CREDIT']

plt.figure(figsize=(10, 6))
plt.hist(data, bins=5, color='skyblue', edgecolor='black')
plt.title('Distribusi AMT_CREDIT')
plt.xlabel('AMT_CREDIT')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()

own_realty = train_drop['FLAG_OWN_REALTY'].value_counts()

plt.figure(figsize=(6, 6))
plt.pie(own_realty, labels=own_realty.index, autopct='%1.1f%%', colors=['skyblue', 'lightgreen'])
plt.title('own realty')
plt.show()

plt.figure(figsize=(10, 6))

sns.barplot(x=train_drop['NAME_HOUSING_TYPE'].value_counts(), y=train_drop['NAME_HOUSING_TYPE'].value_counts().index, hue=train_drop['NAME_HOUSING_TYPE'].value_counts().index, palette='bright', legend=False)
plt.title('housing type')
plt.xlabel('Count')
plt.ylabel('Housing Type')
plt.show()

occupation_counts = train_drop.groupby(['OCCUPATION_TYPE', 'TARGET']).size().unstack(fill_value=0)
occupation_counts['Total'] = occupation_counts.sum(axis=1)
occupation_counts = occupation_counts.sort_values(by='Total', ascending=False)

plt.figure(figsize=(10, 6))
occupation_counts.drop(columns='Total').plot(kind='bar', stacked=True)
plt.title('Distribution of Target Variable by Occupation Type')
plt.xlabel('Occupation Type')
plt.ylabel('Count')
plt.xticks(rotation=55)
plt.legend(title='TARGET', labels=['Target 1', 'Target 0'])
plt.show()

plt.figure(figsize=(12, 6))

occupation_counts = train_drop['OCCUPATION_TYPE'].value_counts().sort_values(ascending=False)

sns.countplot(x='TARGET',hue="OCCUPATION_TYPE", data=train_drop, order=train_drop['TARGET'].value_counts().index, palette='bright')
plt.title("TARGET in each occupation",fontweight="bold", size=10)
plt.show()

plt.figure(figsize=(12, 6))

occupation_counts = train_drop['CNT_FAM_MEMBERS'].value_counts().sort_values(ascending=False)

sns.countplot(x='TARGET',hue="CNT_FAM_MEMBERS", data=train_drop, order=train_drop['TARGET'].value_counts().index, palette='muted')
plt.title("TARGET in each family member",fontweight="bold", size=10)
plt.show()

plt.figure(figsize=(10, 6))

sns.barplot(x=train_drop['NAME_INCOME_TYPE'].value_counts(), y=train_drop['NAME_INCOME_TYPE'].value_counts().index, hue=train_drop['NAME_INCOME_TYPE'].value_counts().index, palette='bright', legend=False)
plt.title('housing type')
plt.xlabel('Count')
plt.ylabel('Housing Type')
plt.show()

income_type = train_drop[(train_drop['NAME_INCOME_TYPE'] != 'Businessman') & (train_drop['NAME_INCOME_TYPE'] != 'Student')]

income = income_type['NAME_INCOME_TYPE'].value_counts()

plt.figure(figsize=(6, 6))

plt.pie(income, labels=income.index, autopct='%1.1f%%')
plt.title('income type')
plt.show()

plt.figure(figsize=(12, 6))

occupation_counts = income_type['NAME_INCOME_TYPE'].value_counts().sort_values(ascending=False)

sns.countplot(x='TARGET',hue="NAME_INCOME_TYPE", data=income_type, order=income_type['TARGET'].value_counts().index, palette='bright')
plt.title("TARGET in each income type",fontweight="bold", size=10)
plt.show()

"""## Laborers"""

laborers = train_drop.loc[train_drop['OCCUPATION_TYPE'] == 'Laborers']
laborers.shape

plt.pie(laborers.groupby(by=["TARGET"]).size(), labels = laborers["TARGET"].unique(),autopct = "%0.2f")
plt.title('laborers target')
plt.show()

plt.pie(laborers.groupby(by=["CODE_GENDER"]).size(), labels = laborers["CODE_GENDER"].unique(),autopct = "%0.2f")
plt.title('laborers gender')
plt.show()

sns.countplot(x=laborers['NAME_EDUCATION_TYPE'], order=laborers['NAME_EDUCATION_TYPE'].value_counts().index)
plt.title('education');
plt.xticks(rotation=35)

sns.countplot(x=laborers['TARGET'], order=laborers['TARGET'].value_counts().index)
plt.title('laborers target');

laborers_income = train_drop[train_drop['OCCUPATION_TYPE'] == 'Laborers']['AMT_INCOME_TOTAL']

plt.figure(figsize=(10, 6))
plt.hist(laborers_income, bins=5, color='skyblue', edgecolor='black')
plt.title('Distribution of Income for Laborers')
plt.xlabel('Income')
plt.ylabel('Frequency')
plt.show()

laborers_credit = train_drop[train_drop['OCCUPATION_TYPE'] == 'Laborers']['AMT_CREDIT']

plt.figure(figsize=(10, 6))
plt.hist(laborers_credit, bins=5, color='skyblue', edgecolor='black')
plt.title('Distribution of Credit for Laborers')
plt.xlabel('Credit')
plt.ylabel('Frequency')
plt.show()

contract = laborers['NAME_CONTRACT_TYPE'].value_counts()

plt.figure(figsize=(6, 6))
plt.pie(contract, labels=contract.index, autopct='%1.1f%%', colors=['skyblue', 'lightgreen'])
plt.title('laborers contract')
plt.show()

realty = laborers['FLAG_OWN_REALTY'].value_counts()

plt.figure(figsize=(6, 6))
plt.pie(realty, labels=realty.index, autopct='%1.1f%%', colors=['skyblue', 'lightgreen'])
plt.title('laborers realty')
plt.show()

"""# Business Insight

Terdapat tantangan signifikan dalam mengelola risiko pembayaran terlambat, dengan sekitar 92% peminjam mengalami keterlambatan. Ini menunjukkan perlunya penilaian kredit yang lebih cermat dan strategi pengelolaan risiko yang lebih efektif, sementara fokus pada penawaran produk peminjaman tunai dapat memberikan keuntungan kompetitif. Dengan 69% peminjam memiliki rumah sendiri, ada peluang untuk mengembangkan produk pinjaman yang berfokus pada pemilik rumah, seperti pinjaman berbasis ekuitas rumah, sementara pekerja buruh, sales staff, dan driver merupakan segmen yang rentan terhadap keterlambatan pembayaran, yang memerlukan strategi khusus untuk mengelola risiko dari segmen-segmen ini.

Berdasarkan fakta tersebut, Untuk mengurangi tingkat keterlambatan pembayaran, diperlukan evaluasi lebih mendalam terhadap pengaturan kredit dan pengelolaan risiko, sementara pengembangan produk baru yang sesuai dengan permintaan pasar, seperti produk pinjaman berbasis rumah tangga, dapat menjadi langkah strategis. Proses penilaian risiko kredit perlu diperkuat, terutama untuk segmen-segmen yang rentan seperti pekerja buruh dan driver.

---

Berdasarkan visualisasi data, dapat dilihat bahwa buruh merupakan kelompok pekerjaan yang paling banyak melakukan peminjaman, dengan jumlah pinjaman mencapai lebih dari 55.000 pinjaman. Sebanyak 90%, buruh menunjukkan adanya keterlambatan pembayaran dalam sejarah pinjaman. tipe kontrak yang dominan di antara buruh adalah pinjaman tunai sebanyak 91%, ketimbang pinjaman bergulir.

Berdasarkan fakta tersebut, Perusahaan perlu melakukan analisis risiko lebih lanjut terhadap kelompok buruh yang memiliki proporsi tinggi untuk mengidentifikasi faktor-faktor yang menyebabkan keterlambatan pembayaran dan mengurangi risiko kerugian. Selain itu, dengan dominannya pinjaman tunai di antara buruh, perusahaan dapat mengembangkan produk-produk pinjaman yang lebih sesuai dengan preferensi mereka, seperti penawaran bunga yang kompetitif dan jangka waktu yang fleksibel.

# Machine Learning Implementation

## Logistic Regression

### Modelling
"""

label_encoder = LabelEncoder()

for column in train_drop.columns:
    if train_drop[column].dtype == 'object':
        train_drop.loc[:, column] = label_encoder.fit_transform(train_drop.loc[:, column])

label_encoder = LabelEncoder()

for column in test_drop.columns:
    if test_drop[column].dtype == 'object':
        test_drop.loc[:, column] = label_encoder.fit_transform(test_drop.loc[:, column])

train_drop.head()

X = train_drop.drop(['TARGET', 'SK_ID_CURR'], axis=1)
y = train_drop['TARGET'].ravel()

print ('X:', X.shape,'\ny:', y.shape)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0, stratify=y)

scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

reg = linear_model.LogisticRegression(max_iter=1000)

reg.fit(X_train, y_train)

y_pred_reg = reg.predict(X_test)

print("Logistic Regression model accuracy(in %):",
      metrics.accuracy_score(y_test, y_pred_reg)*100)

"""### Evaluation"""

cm = confusion_matrix(y_test, y_pred_reg)

# Plot confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['Predicted 0', 'Predicted 1'], yticklabels=['Actual 0', 'Actual 1'])
plt.xlabel('Predicted label')
plt.ylabel('True label')
plt.title('Confusion Matrix')
plt.show()

report = classification_report(y_test, y_pred_reg, zero_division=1)

print(report)

"""### Predict test data"""

testing = test_drop.drop('SK_ID_CURR', axis=1)
testing

cols = testing.columns

scalertest = StandardScaler()
scaledtest = scalertest.fit_transform(testing)

scaled = pd.DataFrame(scaledtest, columns=[cols])

predictions = reg.predict(scaled)

df_test_new = pd.DataFrame(testing)

df_test_new['TARGET'] = predictions

df_test_new

"""## Random Forest Classifier

### Modelling
"""

RF_model = RandomForestClassifier()
RF_model.fit(X_train, y_train)

y_pred_RF = RF_model.predict(X_test)

print("Random Forest model accuracy(in %):",
      accuracy_score(y_test , y_pred_RF)*100)

"""### Evaluation"""

num_folds = 5

RF_model = RandomForestClassifier()

cv_scores = cross_val_score(RF_model, X_train, y_train, cv=num_folds)

print("Cross-validation scores:", cv_scores)
print("Mean accuracy:", cv_scores.mean())

cm_rf = confusion_matrix(y_test, y_pred_RF)

plt.figure(figsize=(8, 6))
sns.heatmap(cm_rf, annot=True, fmt='d', cmap='Blues', xticklabels=['Predicted 0', 'Predicted 1'], yticklabels=['Actual 0', 'Actual 1'])
plt.xlabel('Predicted label')
plt.ylabel('True label')
plt.title('Confusion Matrix')
plt.show()

report_rf = classification_report(y_test, y_pred_reg, zero_division=1)

print(report_rf)

"""# Business Recomendation

**Penyempurnaan Proses Bisnis:**


Evaluasi model yang menghasilkan akurasi yang tinggi seperti Logistic Regression dan Random Forest dapat membantu evaluasi dan menyempurnakan proses bisnis yang ada. Hasil analisis dapat digunakan untuk mengidentifikasi area-area di mana Anda dapat meningkatkan efisiensi operasional dan mengurangi biaya.

**Optimalkan Proses Penilaian Kredit:**


Dengan akurasi yang tinggi dari model klasifikasi, model tersebut dapat digunakan sebagai bagian dari proses penilaian kredit yang lebih efisien. Ini dapat membantu identifikasi dengan lebih tepat calon peminjam yang berisiko tinggi, sehingga dapat mengurangi risiko kredit macet dan meningkatkan profitabilitas perusahaan.

**Pengembangan Produk yang Lebih Tepat Sasaran:**


Dengan memanfaatkan hasil prediksi dari model, dapat dilakukan identifikasi kebutuhan pasar yang belum terpenuhi dan mengembangkan produk atau layanan baru yang lebih sesuai dengan preferensi dan kebutuhan pelanggan. Hal ini dapat membantu meningkatkan daya saing perusahaan dan menghasilkan pendapatan tambahan.
"""